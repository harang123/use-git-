# use-git-
// A summary of how to use the Git

- pwd : 현재 어느 디렉토리에 있는지 알려준다.
(디렉토리 : 컴퓨터에서 파일을 분류하기 위해 사용하는 이름 공간이다.)

- cd 디렉토리 _명 : 현재 위치가 디렉토리_명 위치로 이동하게 된다.
mkdir 폴더_명 : 현재 위치에 폴더_명 이란 폴더가 생성된다.

이제 우리가 버전 관리(데이터 관리)를 하려는 디렉토리를 git에게 알려줘야 함!
- start a working area : 작업을 시작하는 명령어
- clone	     : 깃에게 특정한 저장소를 복제하여 현재 디렉토리에 복사를 하겠다는 것을 뜻한다.
- init	: 현재 디렉토리에다가 작업을 진행하겠다는 것을 깃에게 알려준다.

- git init : .git이란 디렉토리에다가 깃의 저장소를 초기화했다는 뜻이다.
(.git이란 디렉토리는 우리가 버전관리를 하게되면 여러가지 정보들이 생성이 되는데 그 생성된 정보는 저 디렉토리에 저장이 된다. 따라서 .git을 지우면 절대 안된다!! .git 디렉토리는 중요한 파일이다)
- ls -al : 현재 디렉토리의 파일 목록을 보여준다.
clear : 현재 git bash에 보여지고 있는 화면을 깨끗이 지워준다. 

이제 예제로 파일을 관리해 보려한다. 현재 디렉토리에 vim이란 에디터를 사용할 것이다.
이 에디터는 명령어 시스템에서 대부분 설치되어 있기 때문에 어디서나 쓸 수 있다는 장점이 있다.

- vim f1.txt : vim이라는 프로그램으로 'f1.txt'라는 파일을 편집(생성)하겠다 라는 뜻이다.
이렇게 실행을 하면 ~ 물결모양 표시가쭉 뜰텐데 이때는 뭘 입력해도 입력되지 않는다. 왜냐하면 입력 모드가 아니기 때문이다. 이 때 i를 입력하면 하단에 insert라는 것이 뜰 것이다. 이 insert가 뜨면 이제는 무언가를 입력할 수 있는 상태가 되었다는 뜻이다. 

- i : insert모드로 전환하는 명령어이다. insert가 뜨면 입력모드가 되고 파일에 무엇인가를 입력할 수 있게 된다.
insert - souce : 1 => insert 모드에서 souce : 1를 입력하면 파일에 souce : 1이 입력된 것이다.
esc : 현재 insert 모드에서 입력모드를 종료하겠다는 뜻이다. 
다시 무엇인가를 입력하고 싶다면 i를 눌러 insert모드로 변경해 준다. 

정리하자면 i를 누르면 insert가 떠서 입력모드가 되고 esc를 누르면 insert가 없어지면서 명령어를 입력하는 모드가 된다. 

- 이제 작성한 내용들을 저장하고 싶으면 우선 : (콜론) 을 입력한 후 w를 입력하면 되고
동시에 프로그램도 종료하고 싶으면 : (콜론)을 입력한 후 wq를 입력해주면 된다. 
w는 write이고 q는 quit이다. 

- 이렇게 git bash에서 진행하면 현재 디렉토리 파일인 gitfth폴더내에 f1.txt라는 파일이 생성되었으며 그 txt파일 안에 souce : 1이라는 정보가 작성되어 저장이 되는 것을 알 수 있다. 

- 저장된 정보를 확인하고 싶으면 vim f1.txt를 입력해도 되고 cat f1.txt를 입력해도 된다. 

버전관리를 하기 전에 가장 먼저 익혀야 될 명령은 status라는 명령어이다.

git status : 현재 디렉토리의 상태를 보여준다.

이렇게 현재 디렉토리의 상태를 보면 
Untracked files:

  (use "git add <file>..." to include in what will be committed)
        f1.txt
이렇게 t1.txt파일이 untracked files라고 뜨는데 이는 추적되고 있지 않은 파일이라는 뜻이다.
요약하자면 f1.txt라는 파일은 버전관리가 되고 있는 디렉토리인 gitfth안에 존재하지만 
따로 f1.txt파일을 깃에게 버전관리를 시작해! 라고 얘기하기전까지 깃은 얘를 무시하게 된다.
그래서 git add 명령어를 사용하여 git에게 이 파일을 관리해!라고 얘기해 줘야 한다.

git add 파일명 : git에게 파일명 파일을 관리하라고 명령하는 것이다.

이렇게 git add로 f1.txt파일을 추가하고 난 후 git status를 입력하여 상태를 확인하면 
Changes to be committed:

  (use "git rm --cached <file>..." to unstage)
        new file:   f1.txt
f1.txt 는 새로운 파일이다라고 깃이 인식하기 시작한다.
이렇게 자동으로 추가되지 않고 따로 명령어를 통해 파일을 입력하는 이유는 프로젝트를 진행할때 반드시 버전관리가 필요한 파일이 있고 임시적으로 사용하고 버전관리가 따로 필요하지 않은 파일들이 있기 때문이다.

작업한 내용을 이제 새로운 버전으로 만들어서 저장을 해보자.
이렇게 저장이 되고 나면 예전으로 돌아갈 수도 있고 파일의 변경사항 이력을 확인할 수도 있다.

버전 : 의미있는 변화를 뜻함.
ex) 어떠한 작업이 있으면 그 작업이 완결된 상태가 버전이다.

이제 버전을 세팅하기 전에 이 버전을 누가 만들었는지 알려줘야 하기 때문에 이름을 셋팅해야 한다.

git config --global user.name 닉네임
git config --global user.email 이메일주소 
: 저렇게 순서대로 입력하면 이제 내가 작성한 버전은 저 이름과 이메일주소를 포함하고 있는 버전이 된다는 뜻이다.(딱 한번만 셋팅하면 됨)

git commit : vim이 실행되며 현재 디렉터리가 어떤 상태인지를 보여준다. 나한테 정보를 알려주는 것이다.
윗쪽에 #으로 되어있는 부분은 코멘트 부분이기 때문에 무시되는 부분이다.
이제 여기에다가 내가 현재 버전의 메세지를 적는것이다. 버전의 메세지란 이 변화(버전)이 어떤 변화를 담고 있는지, 이 파일들이 왜 변경되었는지 그 이유를 적는 것이 버전 메세지이다. 또는 커밋메세지라고도 한다.

git log : 해당 버전이 잘 생성되었는지를 확인할 수 있다.

만약 버전을 수정하고 싶으면 
vim f1.txt에 들어가서 입력모드에서 데이터를 수정한 후 :wq를 통해 저장하고 나온 뒤 바로 commit을 하는 것이 아니라 git add를 통해 버전 관리 시스템한테 전달을 해 줘야 한다.
git add를 해줘야 하는 이유는 내가 커밋하고자 하는 파일만 커밋할 수 있게 만들어 주기 때문이다.

**git에서 어떠한 새로운 파일이 생겼을때 그 파일에 대한 버전 관리를 깃에게 명령 할때도 add를 사용해야 한다. 또한 어떤 파일에 이미 버전 관리가 되고있는 파일이더라도 수정을하게 되면 add를 사용하여야 한다.
따라서 최초로 추적할 때도 add를 사용하고, 파일이 수정되서 버전을 만들기 전에도 add를 먼저 해야한다.

cp f1.txt f2.txt : f1.txt파일과 똑같은 f2.txt파일을 복사(copy)한다는 뜻이다.

하지만 이렇게 생성을 하고나면 f1.txt파일과 다르게 f2.txt파일은 추적되고있지 않는다. 따라서 git add f2.txt를 사용하여 git에게 f2.txt파일도 버전관리를 하라고 명령을 해야한다.

이제 파일들을 수정하는 방법을 알아보도록 하자!
수정하고 싶은 파일에 대해 
vim 해당파일명
명령어를 사용하여 수정할 수 있다. 
입력모드에서 내용을 변경시킨 후 
저장하고 나온다. 그 이후 add를 이용하여 커밋 대기 상태로 등록시켜준 후 
commit을 사용하여 수정하면 된다.

statge area : commit 대기를 하고 있는 파일들의 모임이라고 할 수 있다. 커밋을 하면 stage위에 있는 파일들이 이제 버전이 되는 것이다.

repository : commit된 결과가 저장된 곳이 repository(저장소)이다.

@@@@@@@@@@@@버전을 만든 이유(효용 대표적인 2가지)@@@@@@@@@
1. 차이점을 알 수 있고 또는 과거 어느 시점의 내용을 알 수 있다.
2. 과거로 돌아갈 수 있다.

git log의 뒤에 여러가지 옵션을 줘서 깃 로그가 동작하는 방법을 바꿀 수 있다.

 과거로 돌아가기(reset)
즉, commit을 취소하는 방법

git log를 검색하면 이때까지의 변경사항들이 나오는데 최신 버전에서 이전의 특정 버전으로 다시 돌아가고 싶을 때 어떻게 돌아가는지를 알아보자!!

돌아가는 방법으로는 크게 2가지 방법이 있다. (--hard 버전 가장 사용하기 쉽지만 위험이 있는 방법으로 나중에 가서 다른 방법을 배울 예정)
1) git reset : 
ex) git reset 돌아가고 싶은 버전의 commit 로그 --hard
이런식으로 적으면 된다.
이러고 엔터를 치면 해당 버전 위의 버전들은 없어지고 해당 버전이 가장 최신 버전으로 로그에 표시된다.
(단, 최신 버전들이 완전히 없어진 것은 아니고 복구 시킬수 있는데 그건 나중에 설명할 예정이다.)

**주의사항 
협업을 하게되어 자신의 버전을 다른 곳에 공유할 수 있는데 공유한 이후에는 절대로 리셋을 하면 안된다. 공유한 버전에 대해서는 리셋 작업을 절대 하면 안됨!

2) git revert : (reset과 비슷한 방식으로 사용한다. 하지만 아직은 이해하기 어렵기 때문에 나중에 자세히 배울 예정)

2가지 방법의 차이점 : revert는 reset과 다르게 완전히 버전들을 날려버리는 것이 아니라 최신 버전들의 커밋을 취소하면서 새로운 버전을 생성한다.(나중에 원리에 대해 자세히 배울 예정)

git - 스스로 공부하는 법
1) 가장 많이 사용되는 것이 무엇인가?를 조사하여 그 기본이 되는 것들을 완벽히 숙지하고 사용한 뒤 그것들을 밑천으로 사용하여 개발해 나가는 방법!!!
2)  1번 방법에서 배웠던 밑천들을 바탕으로 자기가 모르는 것을 알아 낼 수 있는 방법만 있으면 어떠한 분야든 스스로 개발할 수 있다!!

git 또한 마찬가지이다.
1)번 방법에 따라 git의 명령어를 나열하자면 commit, push, pull, clone, checkout, add, branch, log, diff, fetch, merge, init, status, reset, tag, rebase, rm, show, bisect, grep, mb 
이와 같은 순서로 사용빈도와 중요도를 알아 볼 수 있다.

git commit -a : 내가 작성하고 수정하는 파일들을 git add의 과정 없이 자동적으로 add 시켜주는 commit의 옵션이다. 
git commit -m : 따로 에디터를 띄우지 않고 현재 창에서 commit 메세지를 작성하겠다는 뜻이다.
2개를 합쳐서도 사용가능하다. 
git commit -am "commit 메세지"이렇게 사용할 수 있다.
 
GIT : 원리 - git add
보통 git에서 터미널이라 하면 새로운 폴더를 만들어 git init으로 연결해주는 것을 말한다.
vim t1.txt를 실행시켜 내용을 입력하여 파일을 추가하여도 .git에는 아무런 변화가 없
다. 

git branch 명령어를 입력하면
*master가 뜨는데 이 뜻은 현재 master라는 브랜치를 사용하고 있다는 뜻이다.(기본적으로 적용되고있는 브랜치가 master이다.)

새로운 브랜치(branch)만드는 법 : 
git branch 브랜치 이름 
이렇게 적으면 새롭게 만드는 것이다.

이름을 지을 때 테스트용 파일로 사용하고 싶으면 주로 
exp_파일명 이렇게 branch이름을 지어준다.
or 특정한 기능을 추가한 branch일 경우
git branch feature 등등으로 이름을 지을 수 있다.

그다음으로 git branch를 생성하고 난 후 다시 git branch를 입력하면 
  exp
* master
이렇게 2개의 표시가 나타난다. 저기서 색깔이 칠해져있으면서 앞에 *가 달려있는것이 현재 사용중인 브랜치라는 뜻이다.

여기서 브랜치를 exp로 바꾸고 싶을때
git checkout 브랜치명 이렇게 써주면 branch를 바꿀수가 있다.

또한 git branch를 생성하게되면 생성된 branch는 기존의 branch의 상태를 그대로 복사하게 된다.


-------------------------------banch 정보 확인----------------------------

각각의 branch간의 차이점을 비교하고 싶을 때 : 
git log --branches
이 뜻은 현재 자신이 체크아웃 되어있는 브랜치가 아닌 자신으 저장소에 있는 모든 브랜치를 본다는 뜻이고
git log --branches --decorate 라고 치면 마스터 브랜치의 가장 최신 commit이 어디인지, exp 브랜치의 가장 최신 커밋이 무엇인지를 보여준다.

또한 HEAD -> exp의 뜻은 현재 우리는 exp 브랜치에 체크아웃 되어있다는 뜻이다.

여기서 추가적으로 더 보기편하게 하려면 
git log --branches --decorate --graph를 입력하여 준다. 그러면 좌측에 빨간색과 노란색줄이 들어나는데 이것은 진짜 나뭇가지처럼 어떠한 branch가 어떻게 commit되어 왔는지를 쉽게 보여준다. 
ex) master 브랜치는 어떻게 변경되어졌는지와 exp 브랜치는 어떻게 변경되어졌는지를 보여준다.
따라서 master와 exp 브랜치의 공통의 조상 commit이 어디인지도 손쉽게 확인할 수 있다.
